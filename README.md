https://github.com/Ezereul/ugc_sprint_1

# Проектная работа 8 спринта

## Краткое описание системы

UGC (User Generated Content) реализована для работы с контентом, генерируемом пользователями.
Реализованная в этом спринте часть служит для логирования событий, приходящих с фронта от пользователей.

В соответствии с выявленными нами требованиями (представлены ниже) мы выявили четыре типа хранимых сущностей:
- Клик
- Открытая страница
- Кастомные
- Тайминг просмотра фильма


## Руководство по запуску

1. `mv .env.example .env`
2. Установить переменные окружения в файле `.env`
3. `docker compose up`


## Требования

### Функциональные
1. Отслеживание кликов.
Необходимо, чтобы система могла отслеживать и записывать информацию о каждом действии пользователя на сайте, включая клики по различным элементам
2. Отслеживание просмотров страниц.
Необходимо чтобы система могла отслеживать страницы, просматриваемые пользователями на сайте, и сохранять информацию о времени, проведенном на каждой из них.
3. Отслеживание кастомных событий.
Необходимо, чтобы система могла отслеживать индивидуальные события, такие как изменение качества видео, просмотр видео до конца и использование фильтров поиска.
4. Отслеживание просмотренности фильмов.
Необходимо, чтобы система могла отслеживать информацию о том, насколько фильм был просмотрен.

### Нефункциональные
1. Uptime не менее 99.9%.
2. Latency: менее 500 мс для 95 перцентиля, менее 300 мс для 75 перцентиля.
3. 1000 RPS.
4. Error Rate не более 5%.


## Технические детали реализации

Происходящие в системе события приходят на Backend UGC.

В качестве фреймворка мы выбрали Flask. 
Для каждого из событий фронта реализована отдельная ручка.
Ручки записывают каждое из событий в свой топик.
Асинхронность реализована через gevent.
Подробная Swagger-документация доступна по endpoint `/apidocs`.

Для каждого из топиков реализован свой Consumer.
Каждый из Consumer'ов пишет события в свою таблицу в Clickhouse.
Асинхронно они работают через TaskGroup.
Для наших 4 нод репликацию и шардирование определили следующим образом:
1 и 3 нода содержат распределённые таблицы, а 2 и 4 реплики 1 и 3 шардов.
